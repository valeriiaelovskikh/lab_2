#1
def fibonacci(n):
    if n<2: #если меньше n, то возвращается это же число
        return n
    else:
        return (fibonacci(n-1)+fibonacci(n-2)) #если больше, то идет расчет по последовательности Фибоначчи
print(fibonacci(6))

#2
list1 = [1,2,3,4,5,6] #создаем два списка
list2 = [4,5,6,7,8,9]

print(list(set(list1)^set(list2))) #с помощью set похожие элементы и удаляем 

#3
a = [1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 7, 8]
k = 3  # колличество раз, сколько встречается элемент
res = []  # список

for i in set(a):  # set удаляет все дубликаты в списке
    if a.count(i) >= k: # количество раз, когда элемент встречается в списке
        res.append(i)

print('Элементы, встречающееся 3 раза:')
print(res) 

#4

#5
l = [1,2,3,2,4,5,6,7]
def posled(x):
    now = [] #текущая последовательность
    max = [] #максимальная последовательность
    for i in range(len(x)):
        if i == 0 or x[i] <= x[i - 1]: #если текущий элемент меньше или равен предыдущему
            now = [x[i]] #тогда начинается новая текущая последовательность
        else:
            now.append(x[i]) # иначе добавляется к существующей последовательности, текущий элемент
        if len(now) > len(max): #если текущая длиннее наибольшей
            max = now #сохраняем сохраняем эту последовательность в наибольшую
    return max

print(posled(l))

#6
def stroka(x):
    x = ''
    for i in range (len(s)):
        if i % 2 == 0: #делаем чередование
            x += s[i].upper() #делает в слове большую букву
        else:
            x += s[i].lower() #делает в слове маленькую букву
    return x
s = 'красота в пустоте, а не в качестве и колличестве'
print(stroka(s))

#7

#8

#9

#10

